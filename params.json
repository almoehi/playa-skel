{"name":"Playa-skel","tagline":"project template to be used with play2-playa module","body":"play2-playa project template\r\n=====================================\r\nThis project sets up a play-2.2 application with play2-playa module.\r\n\r\nPlaya is a custom and extended Play-2.2\r\nPlaya provides additional features \r\nPlaya is indented to provide some basic infrastructure for Play! Framework to speed up project development. It uses some popular Play! modules and contains several custom extensions.\r\n\r\nPlaya! provides the following features:\r\n=======================================\r\n- Security as provided by deadbolt2 module\r\n- Authorization as provided by securesocial2 module\r\n- Reactive MongoDB driver as provided by reactivemongo\r\n- A slick ready2use AdminUI-Theme based on Bootstrap3 as provided by Bootstrap-Admin-Template\r\n- Custom storage subsystem to easily receive, store and serve files and file uploads\r\n\r\n\r\nAdditional components and extensions:\r\n--------------------------\r\n- Navigation as provided by a custom NavigationManager plugin\r\n- Support for Bootstrap3 forms\r\n- custom form field helpers for file and image uploads (integrates perfect with storage subsystem)\r\n- A bunch of custom form field helpers to support additional and extended form controlls (taglist, multiselect drop-down, date-picker, time-picker, color-picker, masked inputs, ...)\r\n- Custom actions builders to easily access current user object and secure your actions based on user roles\r\n- MongoDB based UserProvider to store user accounts and user roles\r\n- An async storage subsystem (based on gridFS) to remove the pain from handling and serving file uploads from multipart form requests\r\n- Seamless integration of security and storage subsystem allows securing of storage items with user roles\r\n- A simple pagination implementation to build views with paged data\r\n\r\n\r\nSiteContext\r\n========================\r\nPlaya uses a concept called _SiteContext_ to provide features like navigation and access of current user within templates. Therefore, an `implicit ctx:SiteContext` implicit needs to be present in any Admin-UI template. You can simply provide it from inside your controllers like this:\r\n\r\n\timplicit def ctx(implicit request:RequestHeader) = DefaultSiteContext(Some(siteNav), Some(contextNav))\r\n\t\r\nWhere `siteNav` and `contextNav` are instances of `Navigation` to provide a (custom) navigation tree. To simplify this task the `NavigationProvider` trait provides a `defaultSiteContext` which you can use like this:\r\n\r\n\timplicit def ctx(implicit request:RequestHeader) = navigationProvider.defaultSiteContext\r\n\r\nIf you don't need the navigation plugin and are not using the provided Admin-UI template(s) you can ommit this implicit.\r\n\r\n\r\nController Traits\r\n========================\r\nEach module can be used by simply extending your controller with the provided traits.\r\n\r\n\tobject PlayaWelcome extends Controller with MongoController with SecurityActionBuilders with StorageProvider with NavigationProvider {\r\n\t\r\n\t}\r\n\r\n*\t**MongoController:** grants access to mongodb (see [Play-ReactiveMongo](https://github.com/ReactiveMongo/Play-ReactiveMongo))\r\n*   **SecurityActionBuilder:** provides UserWithRoles, UserAwareAction, UserAction action builders\r\n*\t**StorageProvider:** provides a simple to use storage subsystem based on gridFS. Receive, store and serve data or file-uploads\r\n*\t**NavigationProvider:** provides access to `navigationProvider` property and the `defaultSiteContext`\r\n\r\n\r\nMongoDB\r\n========\r\nAccess to MongoDB and GridFS is powered by the async [ReactiveMongo](http://reactivemongo.org/) driver.\r\n\r\nSecurity\r\n========\r\nSecurity subsystem is powered by the [Deadbolt2](https://github.com/schaloner/deadbolt-2-guide) module. However, Playa comes with it's own custom ActionBuilders and template helpers. Your controller needs to extend from the `SecurityActionBuilders` trait.\r\n\r\nSecure an action - user requires at least one of given roles\r\n\r\n\tdef acl = UserWithRolesAction(\"registered\").async { implicit request => \r\n      Future {\r\n        Ok(play.ui.backend.views.html.submodule(\"Submodule with REGISTERED ACL for user: \" + request.user.getIdentifier))\r\n      }\r\n\t}\r\n\r\nSecure with role groups - user requires at least one role of each given role group\r\n\r\n\tdef acl = UserWithRolesAction(List(Seq(\"registered\"))).async { implicit request => \r\n      Future {\r\n        Ok(play.ui.backend.views.html.submodule(\"Submodule with REGISTERED ACL for user: \" + request.user.getIdentifier))\r\n      }\r\n\t}\r\n\t\r\n\r\nAuthorization /w OAuth Support\r\n==============================\r\nAuthorization is provided by the [securesocial2](http://securesocial.ws) module. Guides and docs on how to use it are available on the [securesocial](http://securesocial.ws) website.\r\n\r\nPlaya comes with a UserProvider implementation which stores all users and user roles in MongoDB. Playa supports implicit type conversions between securesocial2 Identity and the Playa user model by importing:\r\n\r\n\timport play.modules.playa.Implicits._\r\n\t\r\nsecure action with (logged in) user\r\n\r\n\tdef acl = UserAction.async { implicit request => \r\n      Future {\r\n        Ok(play.ui.backend.views.html.submodule(\"Submodule with logged-in user: \" + request.user.getIdentifier))\r\n      }\r\n\t}\r\n\t\r\n\r\naction with an optional user\r\n\r\n\tdef acl = UserAwareAction.async { implicit request => \r\n\t  val userName = request.user match {\r\n\t        case Some(user) => user.fullName\r\n\t        case _ => \"guest\"\r\n\t    }\r\n\t    \r\n      Future {\r\n        Ok(play.ui.backend.views.html.submodule(\"Submodule with logged-in user: \" + userName))\r\n      }\r\n\t}\r\n\t\r\n\t\r\nBootstrap3 forms \r\n=================\r\nPlaya provides a default form field constructor to create forms using the Bootstrap3 markup rules.\r\n\r\nCustom form field helpers\r\n==========================\r\nPlaya provides the following custom form field helpers. These helpers support the following default field options as the original Play! field helpers:\r\n\r\n- **_label**: label text or omit for no label\r\n- **class**: add custom CSS classes to input tag `class=\"\"` property\r\n- **placeholder**: placeholder value e.g. for text inputs or an image URL for image fields\r\n- **tooltip**: tooltp text\r\n- **_offset**: apply a bootstrap column offset - this adds a bootstrap CSS class like  `col-lg-offset-X` - useful to align form fields. When mixing forms with labels and no labels use `_offset -> 2` on fields without labels\r\n\r\nList of supported form field helpers:\r\n\r\n\r\n* `@fieldCheckbox(field = myForm(\"fieldName\"))`\r\n* `@fieldCurrency(field = myForm(\"fieldName\"), 'mask -> \"999.999,99\", 'currency -> \"EUR\")`\r\n* `@fieldDatepicker(field = myForm(\"fieldName\"))`\r\n* `@fieldEmail(field = myForm(\"fieldName\"), 'tooltip -> \"Give your email\", 'placeholder -> \"Your Email\")`\r\n* `@fieldFile(field = myForm(\"userFile\"), 'selectButton -> \"select file\", 'removeButton -> \"reset\", 'deleteText -> \"delete current file\")`\r\n* `@fieldHexColor(field = myForm(\"fieldName\"))`\r\n* `@fieldRgbColor(field = myForm(\"fieldName\"))`\r\n* `@inputHidden(field = myForm(\"fieldName\"))`\r\n* `@fieldImage(field = myForm(\"imageFile\"), 'placeholder -> \"some/empty/url\", 'selectButton -> \"select image\", 'removeButton -> \"reset\", 'deleteText -> \"remove current image\")`\r\n* `@fieldLimitedTextarea(field = myForm(\"fieldName\"), 'limit -> 140, 'remainingText -> \"%n remaining\", 'limitText -> \"max %n chars\")`\r\n* `@fieldMultiSelect(field = myForm(\"fieldName\"), options = List((\"de\", \"Germany\"), (\"ca\", \"Canada\")))`\r\n* `@fieldPassword(field = myForm(\"fieldName\"), 'size -> 10, 'tooltip = \"some tooltip\")`\r\n* `@fieldRadio(field = myForm(\"fieldName\"), 'tooltip -> \"radio button text\")`\r\n* `@fieldSelect(field = myForm(\"fieldName\"), options = options(List(\"Yes\",\"No\")), args = 'placeholder -> \"choose value\")`\r\n* `@fieldSpinner(field = myForm(\"fieldName\"), 'step -> 1, 'numberFormat -> \"n\", 'min -> 0, 'max -> 100)`\r\n* `@fieldTags(field = myForm(\"mytags\"), 'placeholder -> \"Type hashtags\")`\r\n* `@fieldText(field = myForm(\"fieldName\"), 'size -> 10, 'placeholder -> \"Your name\", 'mask -> \"9999-99-99\", 'tooltip -> \"date input mask\")`\r\n* `@fieldTextarea(field = myForm(\"fieldName\"), 'placeholder -> \"type your story\")`\r\n* `@fieldDatepicker(field = myForm(\"fieldName\"))`\r\n* `@helper.formButtons(\"submit\", \"cancel\")`\r\n\r\nAdditional template helpers\r\n============================\r\nHelpers to perform role-based security checks of current user within a template:\r\n\r\n\t@helper.security.restrict(List(\"registered\")) {\r\n\t\t  <p>This content should be visible to registered users only</p<\r\n\t}\r\n\t\r\nand using role groups:\r\n\r\n\t@helper.security.restrictAll(List(List(\"registered\"))) {\r\n\t\t  <p>This content should be visible to registered users only</p<\r\n\t}\r\n\r\n\r\nThe `paginator` helper provides rendering of pagination. The current page is appended as a query string parameter `?page=X`:\r\n\r\n\t@paginator(myPager, controllers.Application.myPagedAction)\r\n\t\r\nWhere `myPager` needs to be an `play.modules.playa.service.Pagination.Paginator` implementation.\r\n\r\nStorage subsystem\r\n==================\r\nPlaya provides an easy and straight forward way to store, retrive and serve files from GridFS. It also removes the pain from handling file uploads quite a bit !\r\n\r\nFile Uploads\r\n-------------\r\nPlaya provides an extension to Play! forms to remove the pain from receiving uploaded files.\r\n\r\nYou need to:\r\n\r\n* extend your controller from `StorageProvider` trait to get access to the implicit `gfs` property\r\n* define file field as (regular) text field in your form\r\n* use the `gridFSBodyParser(gfs)` body parser in your form submission action\r\n* use the `form.bindFromMultipartRequest()` to validate and bind form data\r\n\r\nLet's see an example where we define a form with a text field and two file fields. The `userfile1` for an avatar image which can only be accessed by registered users and `userfile2` for another public accessable file.\r\n\r\n\tdef upload = UserAwareAction { implicit request =>\r\n      \tval form = Form(\r\n\t    \t\ttuple(\r\n\t    \t\t\t\t\"name\" -> text,\r\n\t    \t\t\t\t\"userfile1\" -> text,\r\n\t    \t\t\t\t\"userfile2\" -> optional(text)\r\n\t    \t\t)\r\n\t    )\r\n\t    Ok(play.ui.backend.views.html.upload(\"Storage Test\", form))\r\n\t}\r\n  \r\n\r\n\tdef handleUpload = UserAwareAction.async(gridFSBodyParser(gfs)) { implicit request =>\r\n\t\t    val form = Form(\r\n\t\t    \t\ttuple(\r\n\t\t    \t\t\t\t\"name\" -> text,\r\n\t\t    \t\t\t\t\"userfile1\" -> text,\r\n\t\t    \t\t\t\t\"userfile2\" -> optional(text)\r\n\t\t    \t\t)\r\n\t\t    )\r\n\t\t    \r\n\t\t    form.bindFromMultipartRequest(BSONDocument(\"userfile1\" -> BSONDocument(\"requiredRoles\" -> BSONArray(\"registered\")))).map{_.fold(\r\n\t\t    \t\tformWithErrors => Ok(play.ui.backend.views.html.upload(\"Upload Test\", formWithErrors)),\r\n\t\t    \t\tvalue => {\r\n\t\t    \t\t  request.user match {\r\n\t\t    \t\t    case Some(u) => \r\n\t\t    \t\t      play.modules.playa.service.UserProvider.update(u.copy(avatarUrl = Some(controllers.routes.StorageController.imageItem(value._2).url)))\r\n\t\t    \t\t    case _ => None\r\n\t\t    \t\t  }\r\n\t\t    \t\t  Redirect(routes.PlayaWelcome.upload)\t\t    \t\t}\r\n\t\t    )}\r\n    }\r\n    \r\nIn your template you could use Playa's custom form field helpers:\r\n\r\n\t@helper.form(action = routes.PlayaWelcome.handleUpload, 'class -> \"form-horizontal\", 'enctype -> \"multipart/form-data\") {\r\n    \t\t@helper.fieldText(form(\"name\"), '_label -> \"Your name\", 'placeholder -> \"Give some name\", 'tooltip -> \"Name of uploaded file\")\r\n    \t\t@helper.fieldImage(form(\"userfile1\"), '_label -> \"avatar\")\r\n    \t\t@helper.fieldImage(form(\"userfile2\"), '_label -> \"2nd image\")\r\n    \t\t@helper.formButtons()\r\n\t}\r\n\r\nThe form is simply defnied as a tuple of Strings which will contain the storageId (GridFS `_id`) of the uploaded and stored files. The form submission handling is straight forward like you do with every Play! forms. The only difference is the call to `bindFromMultipartRequest` method provided by the Playa form extension and the custom `gridFSBodyParser`\r\n\r\nYou can optionally assign roles to storage items which are required (and checked!) when accessing the storage item from the built-in `StorageController`. Or, yo can just use `bindFromMultipartRequest()` for public accessable items without assigning any roles.\r\n\r\nNote: the sample uses `UserAwareAction` ActionBuilder but you can use the form extensions with with any other Play! action.\r\n\r\nServing storage items with RouterHelper URLs\r\n------------------------------\r\nPlaya comes with a `StorageController` implementation to easily serve your stored files / uploads and a RouteHelper to build URLs in your templates by just using the storageId:\r\n\r\nto serve an image item:\r\n\r\n\t@play.modules.playa.RouteHelper.imageItem(storageId)\r\n\t\r\nto serve an arbitrary storage item:\r\n\r\n\t@play.modules.playa.RouteHelper.storageItem(storageId)\r\n\t\r\nto serve the file with CONTENT_DISPOSITION inline:\r\n\r\n\t@play.modules.playa.RouteHelper.storageItem(storageId)?inline=true\r\n\t\r\nYou can change the route pattern in your `routes.conf`","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}